- issue: "关于文件移动或重命名，Python中内置了多种方案，我们如何选择"
  location: "gqylpy_filesystem.g filesystem.File.{rename,move}"
  create: 2022-10-07
  labels: question
  status: Processed
  description: |
    移动或重命名文件有多个内置函数可选: `os.rename()`, `os.renames()`, `shutil.move()`
    等。它们有何区别，以及哪个更适合我们。
  process:
    2022-10-07: |
      经实测后总结，description中列出的三个内置函数在移动或重命名文件时主要针对 "目标路径已存在"
      和 "目标中间路径不存在" 这两种特殊情况的处理方式不同。

      目标路径已存在：
        os.rename:   引发FileExistsError
        os.renames:  引发FileExistsError
        shutil.move: 当目标路径为文件时，若源路径也为文件则覆盖，若源路径是目录则引发
                     shutil.Error；当目标路径为目录时，若目标路径下不存在与源路径重名的文件或
                     目录，则以目标路径作为父目录，否则引发shutil.Error
      目标中间路径不存在：
        os.rename:   引发FileNotFoundError
        os.renames:  创建，包括任何中间目录
        shutil.move: 引发FileNotFoundError


      `os.renames` 和 `shutil.move` 的源码注释：

      os.renames:
        `os.rename` 的Super版，它是对 `os.rename` 的增强。在移动或重命名文件时，若目标路径
        不存在则会创建目标路径（包括任何中间目录）；在移动或重命名文件后，若源路径为空则会删除源路
        径（从后往前删，直到整个路径被使用或找到一个非空目录）。

      shutil.move:
        递归地将文件或目录移动到另一个位置，类似于Unix的 `mv` 命令，返回值为目标路径。如果目标是
        目录或指向目录的符号链接，则将源移动到目录内，目标路径必须不存在。如果目标已经存在，但不是
        一个目录，它可能会根据 `os.rename` 语义被覆盖。

        如果目标位于当前文件系统上，则使用 `os.rename`。否则，源路径将被复制到目标路径，然后删
        除。如果 `os.rename` 因为跨文件系统重命名而失败，则符号链接将在目标路径下重新创建。

        可选的 `copy_function` 参数是一个可调用对象，它将被用于复制源代码，或者被委托给
        `copytree`。默认情况下，使用 `copy2`，但可以使用支持相同签名的任何函数（如`copy`）。


      综合分析，我们决定使用 `os.rename` 作为重命名方法，它是三者中最基础的，轻量级的，运行速度
      最快。使用 `shutil.move` 作为移动方法，它类似于Unix系统的 `mv` 命令，功能更全面，且更容
      易被大众所接受。另，前者亦可移动，后者亦可重命名。
